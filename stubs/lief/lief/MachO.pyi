from enum import Enum
from typing import Any, ClassVar, Iterator, List, Tuple, overload

import lief

class ARM64_RELOCATION(Enum):
    ARM64_RELOC_UNSIGNED            = 0  # For pointers. 
    ARM64_RELOC_SUBTRACTOR          = 1  # Must be followed by an ARM64_RELOCATION::ARM64_RELOC_UNSIGNED 
    ARM64_RELOC_BRANCH26            = 2  # A B/BL instruction with 26-bit displacement. 
    ARM64_RELOC_PAGE21              = 3  # PC-rel distance to page of target. 
    ARM64_RELOC_PAGEOFF12           = 4  # Offset within page, scaled by MachO::Relocation::size. 
    ARM64_RELOC_GOT_LOAD_PAGE21     = 5  # PC-rel distance to page of GOT slot 
    ARM64_RELOC_GOT_LOAD_PAGEOFF12  = 6  # Offset within page of GOT slot, scaled by MachO::Relocation::size. 
    ARM64_RELOC_POINTER_TO_GOT      = 7  # For pointers to GOT slots. 
    ARM64_RELOC_TLVP_LOAD_PAGE21    = 8  # PC-rel distance to page of TLVP slot. 
    ARM64_RELOC_TLVP_LOAD_PAGEOFF12 = 9  # Offset within page of TLVP slot, scaled by MachO::Relocation::size.
    ARM64_RELOC_ADDEND              = 10  # Must be followed by ARM64_RELOCATION::ARM64_RELOC_PAGE21 or ARM64_RELOCATION::ARM64_RELOC_PAGEOFF12. 

class ARM_RELOCATION(Enum):
    ARM_RELOC_VANILLA            = 0
    ARM_RELOC_PAIR               = 1
    ARM_RELOC_SECTDIFF           = 2
    ARM_RELOC_LOCAL_SECTDIFF     = 3
    ARM_RELOC_PB_LA_PTR          = 4
    ARM_RELOC_BR24               = 5
    ARM_THUMB_RELOC_BR22         = 6
    ARM_THUMB_32BIT_BRANCH       = 7   # obsolete
    ARM_RELOC_HALF               = 8

class BINDING_CLASS(Enum):
    BIND_CLASS_WEAK     = 1
    BIND_CLASS_LAZY     = 2
    BIND_CLASS_STANDARD = 3
    BIND_CLASS_THREADED = 100

class BIND_OPCODES(Enum):
    BIND_OPCODE_DONE                             = 0x00  # It's finished
    BIND_OPCODE_SET_DYLIB_ORDINAL_IMM            = 0x10  # Set ordinal to immediate (lower 4-bits). Used for ordinal numbers from 0-15
    BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB           = 0x20  # Set ordinal to following ULEB128 encoding. Used for ordinal numbers from 16+
    BIND_OPCODE_SET_DYLIB_SPECIAL_IMM            = 0x30  # Set ordinal, with 0 or negative number as immediate. the value is sign extended.
    BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM    = 0x40  # Set the following symbol (NULL-terminated char*).
    BIND_OPCODE_SET_TYPE_IMM                     = 0x50  # Set the type to immediate (lower 4-bits). See BIND_TYPES
    BIND_OPCODE_SET_ADDEND_SLEB                  = 0x60  # Set the addend field to the following SLEB128 encoding.
    BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB      = 0x70  # Set Segment to immediate value, and address to the following SLEB128 encoding
    BIND_OPCODE_ADD_ADDR_ULEB                    = 0x80  # Set the address field to the following SLEB128 encoding.
    BIND_OPCODE_DO_BIND                          = 0x90  # Perform binding of current table row
    BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB            = 0xA0  # Perform binding, also add following ULEB128 as address
    BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED      = 0xB0  # Perform binding, also add immediate (lower 4-bits) using scaling
    BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB = 0xC0  # Perform binding for several symbols (as following ULEB128), and skip several bytes.
    BIND_OPCODE_THREADED                         = 0xD0

    BIND_OPCODE_THREADED_APPLY                            = 0xD0 | 0x01
    BIND_OPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB = 0xD0 | 0x00

class BIND_TYPES(Enum):
    BIND_TYPE_POINTER         = 1
    BIND_TYPE_TEXT_ABSOLUTE32 = 2
    BIND_TYPE_TEXT_PCREL32    = 3

class Binary(lief.Binary):
    class it_commands:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_filter_symbols:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_libraries:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_relocations:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_sections:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_segments:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_symbols:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self, *args, **kwargs) -> Any: ...
    def add_library(self, *args, **kwargs) -> Any: ...
    def add_section(self, *args, **kwargs) -> Any: ...
    def can_remove(self, symbol) -> bool: ...
    def can_remove_symbol(self, symbol_name: str) -> bool: ...
    def extend(self, load_command, size: int) -> bool: ...
    def extend_segment(self, segment_command, size: int) -> bool: ...
    def get(self, *args, **kwargs) -> Any: ...
    def get_section(self, *args, **kwargs) -> Any: ...
    def get_segment(self, *args, **kwargs) -> Any: ...
    def get_symbol(self, *args, **kwargs) -> Any: ...
    def has(self, type: LOAD_COMMAND_TYPES) -> bool: ...
    def has_section(self, name: str) -> bool: ...
    def has_segment(self, name: str) -> bool: ...
    def has_symbol(self, name: str) -> bool: ...
    def is_valid_addr(self, address: int) -> bool: ...
    @overload
    def remove(self, load_command) -> bool: ...
    @overload
    def remove(self, type: LOAD_COMMAND_TYPES) -> bool: ...
    @overload
    def remove(self, symbol) -> bool: ...
    def remove_command(self, index: int) -> bool: ...
    def remove_signature(self) -> bool: ...
    def remove_symbol(self, name: str) -> bool: ...
    def section_from_offset(self, *args, **kwargs) -> Any: ...
    def section_from_virtual_address(self, *args, **kwargs) -> Any: ...
    def segment_from_offset(self, *args, **kwargs) -> Any: ...
    def segment_from_virtual_address(self, *args, **kwargs) -> Any: ...
    @overload
    def unexport(self, name: str) -> bool: ...
    @overload
    def unexport(self, symbol) -> bool: ...
    def virtual_address_to_offset(self, virtual_address: int) -> int: ...
    def write(self, output: str) -> None: ...
    def __contains__(self, arg0: LOAD_COMMAND_TYPES) -> bool: ...
    def __getitem__(self, index) -> Any: ...
    @property
    def build_version(self) -> Any: ...
    @property
    def code_signature(self) -> Any: ...
    @property
    def code_signature_dir(self) -> Any: ...
    @property
    def commands(self) -> Binary.it_commands: ...
    @property
    def data_in_code(self) -> Any: ...
    @property
    def dyld_environment(self) -> Any: ...
    @property
    def dyld_info(self) -> Any: ...
    @property
    def dylinker(self) -> Any: ...
    @property
    def dynamic_symbol_command(self) -> Any: ...
    @property
    def encryption_info(self) -> Any: ...
    @property
    def exported_symbols(self) -> Binary.it_filter_symbols: ...
    @property
    def fat_offset(self) -> int: ...
    @property
    def filesets(self) -> FatBinary.it_binaries: ...
    @property
    def function_starts(self) -> Any: ...
    @property
    def functions(self) -> List[lief.Function]: ...
    @property
    def has_build_version(self) -> bool: ...
    @property
    def has_code_signature(self) -> bool: ...
    @property
    def has_code_signature_dir(self) -> bool: ...
    @property
    def has_data_in_code(self) -> bool: ...
    @property
    def has_dyld_environment(self) -> bool: ...
    @property
    def has_dyld_info(self) -> bool: ...
    @property
    def has_dylinker(self) -> bool: ...
    @property
    def has_dynamic_symbol_command(self) -> bool: ...
    @property
    def has_encryption_info(self) -> bool: ...
    @property
    def has_entrypoint(self) -> bool: ...
    @property
    def has_filesets(self) -> bool: ...
    @property
    def has_function_starts(self) -> bool: ...
    @property
    def has_main_command(self) -> bool: ...
    @property
    def has_rpath(self) -> bool: ...
    @property
    def has_segment_split_info(self) -> bool: ...
    @property
    def has_source_version(self) -> bool: ...
    @property
    def has_sub_framework(self) -> bool: ...
    @property
    def has_symbol_command(self) -> bool: ...
    @property
    def has_thread_command(self) -> bool: ...
    @property
    def has_uuid(self) -> bool: ...
    @property
    def has_version_min(self) -> bool: ...
    @property
    def header(self) -> Any: ...
    @property
    def imagebase(self) -> int: ...
    @property
    def imported_symbols(self) -> Binary.it_filter_symbols: ...
    @property
    def libraries(self) -> Binary.it_libraries: ...
    @property
    def main_command(self) -> Any: ...
    @property
    def off_ranges(self) -> Tuple[int,int]: ...
    @property
    def relocations(self) -> Binary.it_relocations: ...
    @property
    def rpath(self) -> Any: ...
    @property
    def sections(self) -> Binary.it_sections: ...
    @property
    def segment_split_info(self) -> Any: ...
    @property
    def segments(self) -> Binary.it_segments: ...
    @property
    def source_version(self) -> Any: ...
    @property
    def sub_framework(self) -> Any: ...
    @property
    def symbol_command(self) -> Any: ...
    @property
    def symbols(self) -> Binary.it_symbols: ...
    @property
    def thread_command(self) -> Any: ...
    @property
    def unwind_functions(self) -> List[lief.Function]: ...
    @property
    def uuid(self) -> Any: ...
    @property
    def va_ranges(self) -> Tuple[int,int]: ...
    @property
    def version_min(self) -> Any: ...
    @property
    def virtual_size(self) -> int: ...

class BindingInfo(lief.Object):
    addend: int
    address: int
    binding_class: BINDING_CLASS
    binding_type: BIND_TYPES
    library_ordinal: int
    weak_import: bool
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: BindingInfo) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: BindingInfo) -> bool: ...
    @property
    def has_library(self) -> bool: ...
    @property
    def has_segment(self) -> bool: ...
    @property
    def has_symbol(self) -> bool: ...
    @property
    def library(self) -> DylibCommand: ...
    @property
    def original_offset(self) -> int: ...
    @property
    def segment(self) -> SegmentCommand: ...
    @property
    def symbol(self) -> Symbol: ...

class BuildToolVersion(lief.Object):
    class TOOLS:
        __members__: ClassVar[dict] = ...  # read-only
        CLANG: ClassVar[BuildToolVersion.TOOLS] = ...
        LD: ClassVar[BuildToolVersion.TOOLS] = ...
        SWIFT: ClassVar[BuildToolVersion.TOOLS] = ...
        UNKNOWN: ClassVar[BuildToolVersion.TOOLS] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        @overload
        def __eq__(self, other: object) -> bool: ...
        @overload
        def __eq__(self, arg0: int) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        @overload
        def __ne__(self, other: object) -> bool: ...
        @overload
        def __ne__(self, arg0: int) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: BuildToolVersion) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: BuildToolVersion) -> bool: ...
    @property
    def tool(self) -> Any: ...
    @property
    def version(self) -> List[int[3]]: ...

class BuildVersion(LoadCommand):
    class PLATFORMS:
        __members__: ClassVar[dict] = ...  # read-only
        IOS: ClassVar[BuildVersion.PLATFORMS] = ...
        MACOS: ClassVar[BuildVersion.PLATFORMS] = ...
        TVOS: ClassVar[BuildVersion.PLATFORMS] = ...
        UNKNOWN: ClassVar[BuildVersion.PLATFORMS] = ...
        WATCHOS: ClassVar[BuildVersion.PLATFORMS] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        @overload
        def __eq__(self, other: object) -> bool: ...
        @overload
        def __eq__(self, arg0: int) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        @overload
        def __ne__(self, other: object) -> bool: ...
        @overload
        def __ne__(self, arg0: int) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    minos: List[int[3]]
    platform: Any
    sdk: List[int[3]]
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: BuildVersion) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: BuildVersion) -> bool: ...
    @property
    def tools(self) -> List[BuildToolVersion]: ...

class CPU_TYPES:
    __members__: ClassVar[dict] = ...  # read-only
    ANY: ClassVar[CPU_TYPES] = ...
    ARM: ClassVar[CPU_TYPES] = ...
    ARM64: ClassVar[CPU_TYPES] = ...
    I386: ClassVar[CPU_TYPES] = ...
    MC98000: ClassVar[CPU_TYPES] = ...
    POWERPC: ClassVar[CPU_TYPES] = ...
    POWERPC64: ClassVar[CPU_TYPES] = ...
    SPARC: ClassVar[CPU_TYPES] = ...
    __entries: ClassVar[dict] = ...
    x86: ClassVar[CPU_TYPES] = ...
    x86_64: ClassVar[CPU_TYPES] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CodeSignature(LoadCommand):
    data_offset: int
    data_size: int
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: CodeSignature) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: CodeSignature) -> bool: ...

class DataCodeEntry(lief.Object):
    class TYPES:
        __members__: ClassVar[dict] = ...  # read-only
        ABS_JUMP_TABLE_32: ClassVar[DataCodeEntry.TYPES] = ...
        DATA: ClassVar[DataCodeEntry.TYPES] = ...
        JUMP_TABLE_16: ClassVar[DataCodeEntry.TYPES] = ...
        JUMP_TABLE_32: ClassVar[DataCodeEntry.TYPES] = ...
        JUMP_TABLE_8: ClassVar[DataCodeEntry.TYPES] = ...
        UNKNOWN: ClassVar[DataCodeEntry.TYPES] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        @overload
        def __eq__(self, other: object) -> bool: ...
        @overload
        def __eq__(self, arg0: int) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        @overload
        def __ne__(self, other: object) -> bool: ...
        @overload
        def __ne__(self, arg0: int) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    length: int
    offset: int
    type: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: DataCodeEntry) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: DataCodeEntry) -> bool: ...

class DataInCode(LoadCommand):
    data_offset: int
    data_size: int
    def __init__(self, *args, **kwargs) -> None: ...
    def add(self, entry) -> DataInCode: ...
    def __eq__(self, arg0: DataInCode) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: DataInCode) -> bool: ...
    @property
    def entries(self) -> it_data_in_code_entries: ...

class DyldEnvironment(LoadCommand):
    value: str
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: DyldEnvironment) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: DyldEnvironment) -> bool: ...

class DyldInfo(LoadCommand):
    class it_binding_info:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_export_info:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...
    bind: Tuple[int,int]
    bind_opcodes: memoryview
    export_info: Tuple[int,int]
    export_trie: memoryview
    lazy_bind: Tuple[int,int]
    lazy_bind_opcodes: memoryview
    rebase: Tuple[int,int]
    rebase_opcodes: memoryview
    weak_bind: Tuple[int,int]
    weak_bind_opcodes: memoryview
    def __init__(self, *args, **kwargs) -> None: ...
    def set_bind_offset(self, offset: int) -> None: ...
    def set_bind_size(self, size: int) -> None: ...
    def set_export_offset(self, offset: int) -> None: ...
    def set_export_size(self, size: int) -> None: ...
    def set_lazy_bind_offset(self, offset: int) -> None: ...
    def set_lazy_bind_size(self, size: int) -> None: ...
    def set_rebase_offset(self, offset: int) -> None: ...
    def set_rebase_size(self, size: int) -> None: ...
    def set_weak_bind_offset(self, offset: int) -> None: ...
    def set_weak_bind_size(self, size: int) -> None: ...
    def __eq__(self, arg0: DyldInfo) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: DyldInfo) -> bool: ...
    @property
    def bindings(self) -> DyldInfo.it_binding_info: ...
    @property
    def exports(self) -> DyldInfo.it_export_info: ...
    @property
    def show_bind_opcodes(self) -> str: ...
    @property
    def show_export_trie(self) -> str: ...
    @property
    def show_lazy_bind_opcodes(self) -> str: ...
    @property
    def show_rebases_opcodes(self) -> str: ...
    @property
    def show_weak_bind_opcodes(self) -> str: ...

class DylibCommand(LoadCommand):
    compatibility_version: List[int[3]]
    current_version: List[int[3]]
    name: str
    timestamp: int
    def __init__(self, *args, **kwargs) -> None: ...
    def id_dylib(self, *args, **kwargs) -> Any: ...
    def lazy_load_dylib(self, *args, **kwargs) -> Any: ...
    def load_dylib(self, *args, **kwargs) -> Any: ...
    def load_upward_dylib(self, *args, **kwargs) -> Any: ...
    def reexport_dylib(self, *args, **kwargs) -> Any: ...
    def weak_lib(self, *args, **kwargs) -> Any: ...
    def __eq__(self, arg0: DylibCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: DylibCommand) -> bool: ...

class DylinkerCommand(LoadCommand):
    name: str
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: DylinkerCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: DylinkerCommand) -> bool: ...

class DynamicSymbolCommand(LoadCommand):
    external_reference_symbol_offset: int
    external_relocation_offset: int
    idx_external_define_symbol: int
    idx_local_symbol: int
    idx_undefined_symbol: int
    indirect_symbol_offset: int
    local_relocation_offset: int
    module_table_offset: int
    nb_external_define_symbols: int
    nb_external_reference_symbols: int
    nb_external_relocations: int
    nb_indirect_symbols: int
    nb_local_relocations: int
    nb_local_symbols: int
    nb_module_table: int
    nb_toc: int
    nb_undefined_symbols: int
    toc_offset: int
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: DynamicSymbolCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: DynamicSymbolCommand) -> bool: ...

class EXPORT_SYMBOL_FLAGS:
    __members__: ClassVar[dict] = ...  # read-only
    REEXPORT: ClassVar[EXPORT_SYMBOL_FLAGS] = ...
    STUB_AND_RESOLVER: ClassVar[EXPORT_SYMBOL_FLAGS] = ...
    WEAK_DEFINITION: ClassVar[EXPORT_SYMBOL_FLAGS] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class EXPORT_SYMBOL_KINDS:
    __members__: ClassVar[dict] = ...  # read-only
    ABSOLUTE: ClassVar[EXPORT_SYMBOL_KINDS] = ...
    REGULAR: ClassVar[EXPORT_SYMBOL_KINDS] = ...
    THREAD_LOCAL: ClassVar[EXPORT_SYMBOL_KINDS] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class EncryptionInfo(LoadCommand):
    crypt_id: int
    crypt_offset: int
    crypt_size: int
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: EncryptionInfo) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: EncryptionInfo) -> bool: ...

class ExportInfo(lief.Object):
    address: int
    flags: int
    def __init__(self, *args, **kwargs) -> None: ...
    def has(self, Checkiftheflag) -> bool: ...
    def __eq__(self, arg0: ExportInfo) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: ExportInfo) -> bool: ...
    @property
    def alias(self) -> Symbol: ...
    @property
    def alias_library(self) -> DylibCommand: ...
    @property
    def flags_list(self) -> List[EXPORT_SYMBOL_FLAGS]: ...
    @property
    def has_symbol(self) -> bool: ...
    @property
    def kind(self) -> EXPORT_SYMBOL_KINDS: ...
    @property
    def node_offset(self) -> int: ...
    @property
    def symbol(self) -> Symbol: ...

class FILE_TYPES:
    __members__: ClassVar[dict] = ...  # read-only
    BUNDLE: ClassVar[FILE_TYPES] = ...
    CORE: ClassVar[FILE_TYPES] = ...
    DSYM: ClassVar[FILE_TYPES] = ...
    DYLIB: ClassVar[FILE_TYPES] = ...
    DYLIB_STUB: ClassVar[FILE_TYPES] = ...
    DYLINKER: ClassVar[FILE_TYPES] = ...
    EXECUTE: ClassVar[FILE_TYPES] = ...
    FVMLIB: ClassVar[FILE_TYPES] = ...
    KEXT_BUNDLE: ClassVar[FILE_TYPES] = ...
    OBJECT: ClassVar[FILE_TYPES] = ...
    PRELOAD: ClassVar[FILE_TYPES] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FatBinary:
    class it_binaries:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def at(self, *args, **kwargs) -> Any: ...
    def raw(self) -> List[int]: ...
    def take(self, *args, **kwargs) -> Any: ...
    def write(self, filename: str) -> None: ...
    def __getitem__(self, index) -> Any: ...
    def __iter__(self) -> FatBinary.it_binaries: ...
    def __len__(self) -> int: ...
    @property
    def size(self) -> int: ...

class FilesetCommand(LoadCommand):
    file_offset: int
    name: str
    virtual_address: int
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: FilesetCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: FilesetCommand) -> bool: ...
    @property
    def binary(self) -> Binary: ...

class FunctionStarts(LoadCommand):
    data_offset: int
    data_size: int
    functions: List[int]
    def __init__(self, *args, **kwargs) -> None: ...
    def add_function(self, address: int) -> None: ...
    def __eq__(self, arg0: FunctionStarts) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: FunctionStarts) -> bool: ...

class HEADER_FLAGS:
    __members__: ClassVar[dict] = ...  # read-only
    ALLMODSBOUND: ClassVar[HEADER_FLAGS] = ...
    ALLOW_STACK_EXECUTION: ClassVar[HEADER_FLAGS] = ...
    APP_EXTENSION_SAFE: ClassVar[HEADER_FLAGS] = ...
    BINDATLOAD: ClassVar[HEADER_FLAGS] = ...
    BINDS_TO_WEAK: ClassVar[HEADER_FLAGS] = ...
    CANONICAL: ClassVar[HEADER_FLAGS] = ...
    DEAD_STRIPPABLE_DYLIB: ClassVar[HEADER_FLAGS] = ...
    DYLDLINK: ClassVar[HEADER_FLAGS] = ...
    FORCE_FLAT: ClassVar[HEADER_FLAGS] = ...
    HAS_TLV_DESCRIPTORS: ClassVar[HEADER_FLAGS] = ...
    INCRLINK: ClassVar[HEADER_FLAGS] = ...
    LAZY_INIT: ClassVar[HEADER_FLAGS] = ...
    NOFIXPREBINDING: ClassVar[HEADER_FLAGS] = ...
    NOMULTIDEFS: ClassVar[HEADER_FLAGS] = ...
    NOUNDEFS: ClassVar[HEADER_FLAGS] = ...
    NO_HEAP_EXECUTION: ClassVar[HEADER_FLAGS] = ...
    NO_REEXPORTED_DYLIBS: ClassVar[HEADER_FLAGS] = ...
    PIE: ClassVar[HEADER_FLAGS] = ...
    PREBINDABLE: ClassVar[HEADER_FLAGS] = ...
    PREBOUND: ClassVar[HEADER_FLAGS] = ...
    ROOT_SAFE: ClassVar[HEADER_FLAGS] = ...
    SETUID_SAFE: ClassVar[HEADER_FLAGS] = ...
    SPLIT_SEGS: ClassVar[HEADER_FLAGS] = ...
    SUBSECTIONS_VIA_SYMBOLS: ClassVar[HEADER_FLAGS] = ...
    TWOLEVEL: ClassVar[HEADER_FLAGS] = ...
    WEAK_DEFINES: ClassVar[HEADER_FLAGS] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Header(lief.Object):
    cpu_subtype: int
    cpu_type: CPU_TYPES
    file_type: FILE_TYPES
    flags: Any
    magic: MACHO_TYPES
    nb_cmds: int
    reserved: int
    sizeof_cmds: int
    def __init__(self) -> None: ...
    def add(self, flag: HEADER_FLAGS) -> None: ...
    def has(self, flag: HEADER_FLAGS) -> bool: ...
    def remove(self, flag: HEADER_FLAGS) -> None: ...
    def __contains__(self, arg0: HEADER_FLAGS) -> bool: ...
    def __eq__(self, arg0: Header) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg0: HEADER_FLAGS) -> Header: ...
    def __isub__(self, arg0: HEADER_FLAGS) -> Header: ...
    def __ne__(self, arg0: Header) -> bool: ...
    @property
    def flags_list(self) -> Set[HEADER_FLAGS]: ...

class LOAD_COMMAND_TYPES:
    __members__: ClassVar[dict] = ...  # read-only
    BUILD_VERSION: ClassVar[LOAD_COMMAND_TYPES] = ...
    CODE_SIGNATURE: ClassVar[LOAD_COMMAND_TYPES] = ...
    DATA_IN_CODE: ClassVar[LOAD_COMMAND_TYPES] = ...
    DYLD_CHAINED_FIXUPS: ClassVar[LOAD_COMMAND_TYPES] = ...
    DYLD_ENVIRONMENT: ClassVar[LOAD_COMMAND_TYPES] = ...
    DYLD_EXPORTS_TRIE: ClassVar[LOAD_COMMAND_TYPES] = ...
    DYLD_INFO: ClassVar[LOAD_COMMAND_TYPES] = ...
    DYLD_INFO_ONLY: ClassVar[LOAD_COMMAND_TYPES] = ...
    DYLIB_CODE_SIGN_DRS: ClassVar[LOAD_COMMAND_TYPES] = ...
    DYSYMTAB: ClassVar[LOAD_COMMAND_TYPES] = ...
    ENCRYPTION_INFO: ClassVar[LOAD_COMMAND_TYPES] = ...
    ENCRYPTION_INFO_64: ClassVar[LOAD_COMMAND_TYPES] = ...
    FILESET_ENTRY: ClassVar[LOAD_COMMAND_TYPES] = ...
    FUNCTION_STARTS: ClassVar[LOAD_COMMAND_TYPES] = ...
    FVMFILE: ClassVar[LOAD_COMMAND_TYPES] = ...
    IDENT: ClassVar[LOAD_COMMAND_TYPES] = ...
    IDFVMLIB: ClassVar[LOAD_COMMAND_TYPES] = ...
    ID_DYLIB: ClassVar[LOAD_COMMAND_TYPES] = ...
    ID_DYLINKER: ClassVar[LOAD_COMMAND_TYPES] = ...
    LAZY_LOAD_DYLIB: ClassVar[LOAD_COMMAND_TYPES] = ...
    LINKER_OPTIMIZATION_HINT: ClassVar[LOAD_COMMAND_TYPES] = ...
    LINKER_OPTION: ClassVar[LOAD_COMMAND_TYPES] = ...
    LOADFVMLIB: ClassVar[LOAD_COMMAND_TYPES] = ...
    LOAD_DYLIB: ClassVar[LOAD_COMMAND_TYPES] = ...
    LOAD_DYLINKER: ClassVar[LOAD_COMMAND_TYPES] = ...
    LOAD_UPWARD_DYLIB: ClassVar[LOAD_COMMAND_TYPES] = ...
    LOAD_WEAK_DYLIB: ClassVar[LOAD_COMMAND_TYPES] = ...
    MAIN: ClassVar[LOAD_COMMAND_TYPES] = ...
    NOTE: ClassVar[LOAD_COMMAND_TYPES] = ...
    PREBIND_CKSUM: ClassVar[LOAD_COMMAND_TYPES] = ...
    PREBOUND_DYLIB: ClassVar[LOAD_COMMAND_TYPES] = ...
    PREPAGE: ClassVar[LOAD_COMMAND_TYPES] = ...
    REEXPORT_DYLIB: ClassVar[LOAD_COMMAND_TYPES] = ...
    ROUTINES: ClassVar[LOAD_COMMAND_TYPES] = ...
    ROUTINES_64: ClassVar[LOAD_COMMAND_TYPES] = ...
    RPATH: ClassVar[LOAD_COMMAND_TYPES] = ...
    SEGMENT: ClassVar[LOAD_COMMAND_TYPES] = ...
    SEGMENT_64: ClassVar[LOAD_COMMAND_TYPES] = ...
    SEGMENT_SPLIT_INFO: ClassVar[LOAD_COMMAND_TYPES] = ...
    SOURCE_VERSION: ClassVar[LOAD_COMMAND_TYPES] = ...
    SUB_CLIENT: ClassVar[LOAD_COMMAND_TYPES] = ...
    SUB_FRAMEWORK: ClassVar[LOAD_COMMAND_TYPES] = ...
    SUB_LIBRARY: ClassVar[LOAD_COMMAND_TYPES] = ...
    SUB_UMBRELLA: ClassVar[LOAD_COMMAND_TYPES] = ...
    SYMSEG: ClassVar[LOAD_COMMAND_TYPES] = ...
    SYMTAB: ClassVar[LOAD_COMMAND_TYPES] = ...
    THREAD: ClassVar[LOAD_COMMAND_TYPES] = ...
    TWOLEVEL_HINTS: ClassVar[LOAD_COMMAND_TYPES] = ...
    UNIXTHREAD: ClassVar[LOAD_COMMAND_TYPES] = ...
    UUID: ClassVar[LOAD_COMMAND_TYPES] = ...
    VERSION_MIN_IPHONEOS: ClassVar[LOAD_COMMAND_TYPES] = ...
    VERSION_MIN_MACOSX: ClassVar[LOAD_COMMAND_TYPES] = ...
    VERSION_MIN_TVOS: ClassVar[LOAD_COMMAND_TYPES] = ...
    VERSION_MIN_WATCHOS: ClassVar[LOAD_COMMAND_TYPES] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LoadCommand(lief.Object):
    command: LOAD_COMMAND_TYPES
    command_offset: int
    data: List[int]
    size: int
    def __init__(self) -> None: ...
    def __eq__(self, arg0: LoadCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: LoadCommand) -> bool: ...

class MACHO_TYPES:
    __members__: ClassVar[dict] = ...  # read-only
    CIGAM: ClassVar[MACHO_TYPES] = ...
    CIGAM_64: ClassVar[MACHO_TYPES] = ...
    FAT_CIGAM: ClassVar[MACHO_TYPES] = ...
    FAT_MAGIC: ClassVar[MACHO_TYPES] = ...
    MAGIC: ClassVar[MACHO_TYPES] = ...
    MAGIC_64: ClassVar[MACHO_TYPES] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MainCommand(LoadCommand):
    entrypoint: int
    stack_size: int
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: MainCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: MainCommand) -> bool: ...

class PPC_RELOCATION:
    __members__: ClassVar[dict] = ...  # read-only
    BR14: ClassVar[PPC_RELOCATION] = ...
    BR24: ClassVar[PPC_RELOCATION] = ...
    HA16: ClassVar[PPC_RELOCATION] = ...
    HA16_SECTDIFF: ClassVar[PPC_RELOCATION] = ...
    HI16: ClassVar[PPC_RELOCATION] = ...
    HI16_SECTDIFF: ClassVar[PPC_RELOCATION] = ...
    JBSR: ClassVar[PPC_RELOCATION] = ...
    LO14: ClassVar[PPC_RELOCATION] = ...
    LO14_SECTDIFF: ClassVar[PPC_RELOCATION] = ...
    LO16: ClassVar[PPC_RELOCATION] = ...
    LO16_SECTDIFF: ClassVar[PPC_RELOCATION] = ...
    LOCAL_SECTDIFF: ClassVar[PPC_RELOCATION] = ...
    PAIR: ClassVar[PPC_RELOCATION] = ...
    PB_LA_PTR: ClassVar[PPC_RELOCATION] = ...
    SECTDIFF: ClassVar[PPC_RELOCATION] = ...
    VANILLA: ClassVar[PPC_RELOCATION] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ParserConfig:
    deep: ClassVar[ParserConfig] = ...  # read-only
    quick: ClassVar[ParserConfig] = ...  # read-only
    parse_dyld_bindings: bool
    parse_dyld_exports: bool
    parse_dyld_rebases: bool
    def __init__(self) -> None: ...
    def full_dyldinfo(self, flag: bool) -> ParserConfig: ...

class REBASE_OPCODES:
    __members__: ClassVar[dict] = ...  # read-only
    ADD_ADDR_IMM_SCALED: ClassVar[REBASE_OPCODES] = ...
    ADD_ADDR_ULEB: ClassVar[REBASE_OPCODES] = ...
    DONE: ClassVar[REBASE_OPCODES] = ...
    DO_REBASE_ADD_ADDR_ULEB: ClassVar[REBASE_OPCODES] = ...
    DO_REBASE_IMM_TIMES: ClassVar[REBASE_OPCODES] = ...
    DO_REBASE_ULEB_TIMES: ClassVar[REBASE_OPCODES] = ...
    DO_REBASE_ULEB_TIMES_SKIPPING_ULEB: ClassVar[REBASE_OPCODES] = ...
    SET_SEGMENT_AND_OFFSET_ULEB: ClassVar[REBASE_OPCODES] = ...
    SET_TYPE_IMM: ClassVar[REBASE_OPCODES] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class REBASE_TYPES:
    __members__: ClassVar[dict] = ...  # read-only
    POINTER: ClassVar[REBASE_TYPES] = ...
    TEXT_ABSOLUTE32: ClassVar[REBASE_TYPES] = ...
    TEXT_PCREL32: ClassVar[REBASE_TYPES] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RELOCATION_ORIGINS:
    __members__: ClassVar[dict] = ...  # read-only
    DYLDINFO: ClassVar[RELOCATION_ORIGINS] = ...
    RELOC_TABLE: ClassVar[RELOCATION_ORIGINS] = ...
    UNKNOWN: ClassVar[RELOCATION_ORIGINS] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RPathCommand(LoadCommand):
    path: str
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: RPathCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: RPathCommand) -> bool: ...

class Relocation(lief.Relocation):
    address: int
    pc_relative: bool
    type: int
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: Relocation) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: Relocation) -> bool: ...
    @property
    def architecture(self) -> CPU_TYPES: ...
    @property
    def has_section(self) -> bool: ...
    @property
    def has_segment(self) -> bool: ...
    @property
    def has_symbol(self) -> bool: ...
    @property
    def origin(self) -> RELOCATION_ORIGINS: ...
    @property
    def section(self) -> Section: ...
    @property
    def segment(self) -> SegmentCommand: ...
    @property
    def symbol(self) -> Symbol: ...

class RelocationDyld(Relocation):
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: RelocationDyld) -> bool: ...
    def __ge__(self, arg0: RelocationDyld) -> bool: ...
    def __gt__(self, arg0: RelocationDyld) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, arg0: RelocationDyld) -> bool: ...
    def __lt__(self, arg0: RelocationDyld) -> bool: ...
    def __ne__(self, arg0: RelocationDyld) -> bool: ...

class RelocationObject(Relocation):
    value: int
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: RelocationObject) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: RelocationObject) -> bool: ...
    @property
    def is_scattered(self) -> bool: ...

class SECTION_FLAGS:
    __members__: ClassVar[dict] = ...  # read-only
    DEBUG: ClassVar[SECTION_FLAGS] = ...
    EXT_RELOC: ClassVar[SECTION_FLAGS] = ...
    LIVE_SUPPORT: ClassVar[SECTION_FLAGS] = ...
    LOC_RELOC: ClassVar[SECTION_FLAGS] = ...
    NO_DEAD_STRIP: ClassVar[SECTION_FLAGS] = ...
    NO_TOC: ClassVar[SECTION_FLAGS] = ...
    PURE_INSTRUCTIONS: ClassVar[SECTION_FLAGS] = ...
    SELF_MODIFYING_CODE: ClassVar[SECTION_FLAGS] = ...
    SOME_INSTRUCTIONS: ClassVar[SECTION_FLAGS] = ...
    STRIP_STATIC_SYMS: ClassVar[SECTION_FLAGS] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SECTION_TYPES:
    __members__: ClassVar[dict] = ...  # read-only
    COALESCED: ClassVar[SECTION_TYPES] = ...
    CSTRING_LITERALS: ClassVar[SECTION_TYPES] = ...
    DTRACE_DOF: ClassVar[SECTION_TYPES] = ...
    GB_ZEROFILL: ClassVar[SECTION_TYPES] = ...
    INTERPOSING: ClassVar[SECTION_TYPES] = ...
    LAZY_DYLIB_SYMBOL_POINTERS: ClassVar[SECTION_TYPES] = ...
    LAZY_SYMBOL_POINTERS: ClassVar[SECTION_TYPES] = ...
    LITERAL_POINTERS: ClassVar[SECTION_TYPES] = ...
    MOD_INIT_FUNC_POINTERS: ClassVar[SECTION_TYPES] = ...
    MOD_TERM_FUNC_POINTERS: ClassVar[SECTION_TYPES] = ...
    NON_LAZY_SYMBOL_POINTERS: ClassVar[SECTION_TYPES] = ...
    REGULAR: ClassVar[SECTION_TYPES] = ...
    SYMBOL_STUBS: ClassVar[SECTION_TYPES] = ...
    S_16BYTE_LITERALS: ClassVar[SECTION_TYPES] = ...
    S_4BYTE_LITERALS: ClassVar[SECTION_TYPES] = ...
    S_8BYTE_LITERALS: ClassVar[SECTION_TYPES] = ...
    THREAD_LOCAL_INIT_FUNCTION_POINTERS: ClassVar[SECTION_TYPES] = ...
    THREAD_LOCAL_REGULAR: ClassVar[SECTION_TYPES] = ...
    THREAD_LOCAL_VARIABLES: ClassVar[SECTION_TYPES] = ...
    THREAD_LOCAL_VARIABLE_POINTERS: ClassVar[SECTION_TYPES] = ...
    THREAD_LOCAL_ZEROFILL: ClassVar[SECTION_TYPES] = ...
    ZEROFILL: ClassVar[SECTION_TYPES] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SYMBOL_ORIGINS:
    __members__: ClassVar[dict] = ...  # read-only
    DYLD_EXPORT: ClassVar[SYMBOL_ORIGINS] = ...
    LC_SYMTAB: ClassVar[SYMBOL_ORIGINS] = ...
    UNKNOWN: ClassVar[SYMBOL_ORIGINS] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Section(lief.Section):
    alignment: int
    flags: int
    numberof_relocations: int
    relocation_offset: int
    reserved1: int
    reserved2: int
    reserved3: int
    segment_name: str
    type: SECTION_TYPES
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, section_name: str) -> None: ...
    @overload
    def __init__(self, section_name: str, content: List[int]) -> None: ...
    def add(self, flag: SECTION_FLAGS) -> None: ...
    def has(self, flag: SECTION_FLAGS) -> bool: ...
    def remove(self, flag: SECTION_FLAGS) -> None: ...
    def __contains__(self, arg0: SECTION_FLAGS) -> bool: ...
    def __eq__(self, arg0: Section) -> bool: ...
    def __hash__(self) -> int: ...
    def __iadd__(self, arg0: SECTION_FLAGS) -> Section: ...
    def __isub__(self, arg0: SECTION_FLAGS) -> Section: ...
    def __ne__(self, arg0: Section) -> bool: ...
    @property
    def flags_list(self) -> Set[SECTION_FLAGS]: ...
    @property
    def has_segment(self) -> bool: ...
    @property
    def relocations(self) -> SegmentCommand.it_relocations: ...
    @property
    def segment(self) -> SegmentCommand: ...

class SegmentCommand(LoadCommand):
    class it_relocations:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_sections:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...
    content: memoryview
    file_offset: int
    file_size: int
    flags: int
    init_protection: int
    max_protection: int
    name: object
    numberof_sections: int
    virtual_address: int
    virtual_size: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: str, arg1: List[int]) -> None: ...
    def add_section(self, *args, **kwargs) -> Any: ...
    def has(self, section) -> bool: ...
    def has_section(self, section_name: str) -> bool: ...
    def __eq__(self, arg0: SegmentCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: SegmentCommand) -> bool: ...
    @property
    def index(self) -> int: ...
    @property
    def relocations(self) -> SegmentCommand.it_relocations: ...
    @property
    def sections(self) -> SegmentCommand.it_sections: ...

class SegmentSplitInfo(LoadCommand):
    data_offset: int
    data_size: int
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: SegmentSplitInfo) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: SegmentSplitInfo) -> bool: ...

class SourceVersion(LoadCommand):
    version: List[int[5]]
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: SourceVersion) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: SourceVersion) -> bool: ...

class SubFramework(LoadCommand):
    umbrella: str
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: SubFramework) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: SubFramework) -> bool: ...

class Symbol(lief.Symbol):
    description: int
    numberof_sections: int
    type: int
    def __init__(self) -> None: ...
    def __eq__(self, arg0: Symbol) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: Symbol) -> bool: ...
    @property
    def binding_info(self) -> Any: ...
    @property
    def demangled_name(self) -> str: ...
    @property
    def export_info(self) -> Any: ...
    @property
    def has_binding_info(self) -> bool: ...
    @property
    def has_export_info(self) -> bool: ...
    @property
    def origin(self) -> SYMBOL_ORIGINS: ...

class SymbolCommand(LoadCommand):
    numberof_symbols: int
    strings_offset: int
    strings_size: int
    symbol_offset: int
    def __init__(self) -> None: ...
    def __eq__(self, arg0: SymbolCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: SymbolCommand) -> bool: ...

class ThreadCommand(LoadCommand):
    architecture: CPU_TYPES
    count: int
    flavor: int
    state: List[int]
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: ThreadCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: ThreadCommand) -> bool: ...
    @property
    def pc(self) -> int: ...

class UUIDCommand(LoadCommand):
    uuid: List[int[16]]
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: UUIDCommand) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: UUIDCommand) -> bool: ...

class VM_PROTECTIONS:
    __members__: ClassVar[dict] = ...  # read-only
    EXECUTE: ClassVar[VM_PROTECTIONS] = ...
    READ: ClassVar[VM_PROTECTIONS] = ...
    WRITE: ClassVar[VM_PROTECTIONS] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VersionMin(LoadCommand):
    sdk: List[int[3]]
    version: List[int[3]]
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, arg0: VersionMin) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: VersionMin) -> bool: ...

class X86_64_RELOCATION:
    __members__: ClassVar[dict] = ...  # read-only
    BRANCH: ClassVar[X86_64_RELOCATION] = ...
    GOT: ClassVar[X86_64_RELOCATION] = ...
    GOT_LOAD: ClassVar[X86_64_RELOCATION] = ...
    SIGNED: ClassVar[X86_64_RELOCATION] = ...
    SIGNED_1: ClassVar[X86_64_RELOCATION] = ...
    SIGNED_2: ClassVar[X86_64_RELOCATION] = ...
    SIGNED_4: ClassVar[X86_64_RELOCATION] = ...
    SUBTRACTOR: ClassVar[X86_64_RELOCATION] = ...
    TLV: ClassVar[X86_64_RELOCATION] = ...
    UNSIGNED: ClassVar[X86_64_RELOCATION] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class X86_RELOCATION:
    __members__: ClassVar[dict] = ...  # read-only
    LOCAL_SECTDIFF: ClassVar[X86_RELOCATION] = ...
    PAIR: ClassVar[X86_RELOCATION] = ...
    PB_LA_PTR: ClassVar[X86_RELOCATION] = ...
    SECTDIFF: ClassVar[X86_RELOCATION] = ...
    TLV: ClassVar[X86_RELOCATION] = ...
    VANILLA: ClassVar[X86_RELOCATION] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    @overload
    def __eq__(self, other: object) -> bool: ...
    @overload
    def __eq__(self, arg0: int) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    @overload
    def __ne__(self, other: object) -> bool: ...
    @overload
    def __ne__(self, arg0: int) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class it_data_in_code_entries:
    def __init__(self, *args, **kwargs) -> None: ...
    def __getitem__(self, index) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __next__(self) -> Any: ...

def check_layout(file: Binary) -> Tuple[bool,str]: ...
def is_64(file: str) -> bool: ...
def is_fat(file: str) -> bool: ...
@overload
def is_macho(filename: str) -> bool: ...
@overload
def is_macho(raw: List[int]) -> bool: ...
def parse(*args, **kwargs) -> Any: ...

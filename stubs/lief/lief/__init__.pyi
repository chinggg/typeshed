from enum import Enum
from typing import Any, ClassVar, Iterator, List, Set, overload

from . import ELF

class Binary(Object):
    class VA_TYPES(Enum):
        AUTO = 0  # Try to guess if it's relative or not    rthomas, 28/01/22 01:50 â€¢ This commit cleans a
        RVA = 1  # Relative
        VA = 2  # Absolute

    class it_relocations:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_sections:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...

    class it_symbols:
        def __init__(self, *args, **kwargs) -> None: ...
        def __getitem__(self, index) -> Any: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __next__(self) -> Any: ...
    name: str
    def __init__(self, *args, **kwargs) -> None: ...
    def get_content_from_virtual_address(self, virtual_address: int, size: int, va_type: Binary.VA_TYPES = ...) -> List[int]: ...
    def get_function_address(self, function_name: str) -> int: ...
    def get_symbol(self, *args, **kwargs) -> Any: ...
    def has_symbol(self, symbol_name: str) -> bool: ...
    def offset_to_virtual_address(self, offset: int, slide: int = ...) -> int: ...
    @overload
    def patch_address(self, address: int, patch_value: List[int], va_type: Binary.VA_TYPES = ...) -> None: ...
    @overload
    def patch_address(self, address: int, patch_value: int, size: int = ..., va_type: Binary.VA_TYPES = ...) -> None: ...
    def remove_section(self, name: str, clear: bool = ...) -> None: ...
    def xref(self, virtual_address: int) -> List[int]: ...
    @property
    def abstract(self) -> object: ...
    @property
    def concrete(self) -> object: ...
    @property
    def ctor_functions(self) -> Any: ...
    @property
    def entrypoint(self) -> int: ...
    @property
    def exported_functions(self) -> Any: ...
    @property
    def format(self) -> EXE_FORMATS: ...
    @property
    def has_nx(self) -> bool: ...
    @property
    def header(self) -> Any: ...
    @property
    def imagebase(self) -> int: ...
    @property
    def imported_functions(self) -> Any: ...
    @property
    def is_pie(self) -> bool: ...
    @property
    def libraries(self) -> Any: ...
    @property
    def relocations(self) -> Binary.it_relocations: ...
    @property
    def sections(self) -> Any: ...
    @property
    def symbols(self) -> Binary.it_symbols: ...

class ENDIANNESS(Enum):
    ENDIAN_NONE = 0
    ENDIAN_BIG = 1
    ENDIAN_LITTLE = 2

class EXE_FORMATS:
    FORMAT_UNKNOWN = 0
    FORMAT_ELF = 1  # ELF. See: LIEF::ELF
    FORMAT_PE = 2  # PE. See: LIEF::PE
    FORMAT_MACHO = 3  # Mach-O. See: LIEF::MachO

class Function(Symbol):
    class FLAGS(Enum):
        CONSTRUCTOR = 0
        DEBUG = 1
        DESTRUCTOR = 2
        EXPORTED = 3
        IMPORTED = 4
    address: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    @overload
    def __init__(self, arg0: str, arg1: int) -> None: ...
    def add(self, flag: Function.FLAGS) -> Function: ...
    @property
    def flags(self) -> List[Function.FLAGS]: ...

class Header(Object):
    architecture: Any
    endianness: ENDIANNESS
    entrypoint: int
    modes: Set[MODES]
    object_type: OBJECT_TYPES
    def __init__(self) -> None: ...
    @property
    def is_32(self) -> bool: ...
    @property
    def is_64(self) -> bool: ...

class MODES(Enum):
    MODE_NONE = 0
    MODE_16 = 1
    MODE_32 = 2
    MODE_64 = 3
    MODE_ARM = 4
    MODE_THUMB = 5
    MODE_MCLASS = 6
    MODE_MICRO = 7
    MODE_MIPS3 = 8
    MODE_MIPS32R6 = 9
    MODE_MIPSGP64 = 10
    MODE_V7 = 11
    MODE_V8 = 12
    MODE_V9 = 13
    MODE_MIPS32 = 14
    MODE_MIPS64 = 15

class OBJECT_TYPES(Enum):
    TYPE_NONE = 0
    TYPE_EXECUTABLE = 1
    TYPE_LIBRARY = 2
    TYPE_OBJECT = 3

class Object:
    def __init__(self, *args, **kwargs) -> None: ...

class PLATFORMS(Enum):
    UNKNOWN = 0
    LINUX = 1
    ANDROID_PLAT = 2
    WINDOWS = 3
    IOS = 4
    OSX = 5

class Relocation(Object):
    address: int
    size: int
    def __init__(self, address: int = ..., size: int = ...) -> None: ...
    def __eq__(self, arg0) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0) -> bool: ...

class Section(Object):
    content: memoryview
    name: object
    offset: int
    size: int
    virtual_address: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def search(self, number: int, pos: int = ..., size: int = ...) -> int: ...
    @overload
    def search(self, str: str, pos: int = ...) -> int: ...
    @overload
    def search_all(self, number: int, size: int = ...) -> List[int]: ...
    @overload
    def search_all(self, str: str) -> List[int]: ...
    @property
    def entropy(self) -> float: ...
    @property
    def fullname(self) -> str: ...

class Symbol(Object):
    name: object
    size: int
    value: int
    def __init__(self) -> None: ...

class bad_file(exception): ...
class bad_format(bad_file): ...
class builder_error(exception): ...
class conversion_error(exception): ...
class corrupted(exception): ...
class exception(Exception): ...
class integrity_error(exception): ...

class lief_errors(Enum):
    read_error = (1,)
    not_found = 2
    not_implemented = 3
    not_supported = 4

    corrupted = 5
    conversion_error = 6

    read_out_of_bound = 7
    asn1_bad_tag = 8
    file_error = 9

    file_format_error = 10
    parsing_error = 11
    build_error = 12

    data_too_large = 13

class not_found(exception): ...
class not_implemented(exception): ...
class not_supported(exception): ...

class ok_t:
    def __init__(self, *args, **kwargs) -> None: ...
    def __bool__(self) -> bool: ...

class parser_error(exception): ...
class pe_bad_section_name(pe_error): ...
class pe_error(exception): ...
class read_out_of_bound(exception): ...
class type_error(exception): ...

@overload
def art_version(filename: str) -> int: ...
@overload
def art_version(raw: List[int]) -> int: ...
def breakp() -> object: ...
def current_platform() -> PLATFORMS: ...
def demangle(arg0: str) -> object: ...
@overload
def dex_version(filename: str) -> int: ...
@overload
def dex_version(raw: List[int]) -> int: ...
@overload
def hash(arg0: Object) -> int: ...
@overload
def hash(arg0: List[int]) -> int: ...
@overload
def hash(arg0: bytes) -> int: ...
@overload
def hash(arg0: str) -> int: ...
@overload
def is_art(filename: str) -> bool: ...
@overload
def is_art(raw: List[int]) -> bool: ...
@overload
def is_dex(filename: str) -> bool: ...
@overload
def is_dex(raw: List[int]) -> bool: ...
@overload
def is_elf(filename: str) -> bool: ...
@overload
def is_elf(raw: List[int]) -> bool: ...
@overload
def is_macho(filename: str) -> bool: ...
@overload
def is_macho(raw: List[int]) -> bool: ...
@overload
def is_oat(filename: str) -> bool: ...
@overload
def is_oat(raw: List[int]) -> bool: ...
@overload
def is_oat(elf: ELF.Binary) -> bool: ...
@overload
def is_pe(filename: str) -> bool: ...
@overload
def is_pe(raw: List[int]) -> bool: ...
@overload
def is_vdex(filename: str) -> bool: ...
@overload
def is_vdex(raw: List[int]) -> bool: ...
@overload
def oat_version(filename: str) -> int: ...
@overload
def oat_version(raw: List[int]) -> int: ...
@overload
def oat_version(elf: ELF.Binary) -> int: ...
@overload
def parse(raw: bytes, name: str = ...) -> Binary: ...
@overload
def parse(filepath: str) -> Binary: ...
@overload
def parse(raw: List[int], name: str = ...) -> Binary: ...
@overload
def parse(io: object, name: str = ...) -> Binary: ...
def shell() -> object: ...
def to_json(arg0: Object) -> str: ...
def to_json_from_abstract(arg0: Object) -> str: ...
@overload
def vdex_version(filename: str) -> int: ...
@overload
def vdex_version(raw: List[int]) -> int: ...
